///////////////////////////////////////////////////////////
//  ChampionsProcessor.cs
//  Implementation of the Class ChampionsProcessor
//  Generated by Enterprise Architect
//  Created on:      04-Apr-2015 3:40:55 PM
//  Original author: Marko
///////////////////////////////////////////////////////////




using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Windows;
using System.Xml;
using LoL_URF_HybridStats_vs12.Helper;
using LoL_URF_HybridStats_vs12.Model;
using LoL_URF_HybridStats_vs12.Model.Helper;
using RiotSharp;
using RiotSharp.MatchEndpoint;
using RiotSharp.StaticDataEndpoint;

[Serializable]
public class ChampionsProcessor : ISerializable
{

    private string apiKey = "6d866a5a-716c-4b87-8b32-7d6080aa3770";
    private ObservableDictionary<int, ChampionStats> champs;
    public int noOfMatches;

    public ObservableDictionary<int, ChampionStats> Champs
    {
        get
        {
            return champs;
        }
    }

	public ChampionsProcessor(){
        champs = new ObservableDictionary<int, ChampionStats>();
        noOfMatches = 0;
	}
    /*
    public void TransferInfoToStats()
    {
        champs = new ObservableDictionary<int, ChampionStats>();
        foreach (KeyValuePair<int, ChampionInfo> champ in champions)
        {
            ChampionInfo c = champ.Value;
            ChampionStats stats = new ChampionStats(c.Id, c.Name, c.Title);
            stats.BannedCount = c.BannedCount;
            stats.DamageDealt = c.DamageDealt;
            stats.DamageTaken = c.DamageTaken;
            stats.GoldEarned = c.GoldEarned;
            stats.ImgCardLocation = c.ImgCardLocation;
            stats.MvpCount = c.MvpCount;
            stats.NoOfAssists = c.NoOfAssists;
            stats.NoOfDeaths = c.NoOfDeaths;
            stats.NoOfKills = c.NoOfKills;
            stats.NoOfLosses = c.NoOfLosses;
            stats.NoOfLvl30 = c.NoOfLvl30;
            stats.NoOfMinions = c.NoOfMinions;
            stats.NoOfPlayedGames = c.NoOfPlayedGames;
            stats.NoOfSoloKills = c.NoOfSoloKills;
            stats.NoOfWins = c.NoOfWins;
            foreach (List<long> pentakillItems in c.PentakillItems)
            {
                stats.PentakillItems.Add(pentakillItems);
            }

            champs.Add(champ.Key, stats);
        }
        champions.Clear();
    }
    */
    public void AddProcessorsData(List<ChampionsProcessor> processors)
    {
        foreach (ChampionsProcessor proc in processors)
        {
            noOfMatches += proc.noOfMatches;
            foreach (KeyValuePair<int, ChampionStats> champ in champs)
            {
                int champId = champ.Key;
                champs[champId].BannedCount += proc.Champs[champId].BannedCount;
                champs[champId].DamageDealt += proc.Champs[champId].DamageDealt;
                champs[champId].DamageTaken += proc.Champs[champId].DamageTaken;
                champs[champId].GoldEarned += proc.Champs[champId].GoldEarned;
                champs[champId].MvpCount += proc.Champs[champId].MvpCount;
                champs[champId].NoOfAssists += proc.Champs[champId].NoOfAssists;
                champs[champId].NoOfDeaths += proc.Champs[champId].NoOfDeaths;
                champs[champId].NoOfKills += proc.Champs[champId].NoOfKills;
                champs[champId].NoOfLosses += proc.Champs[champId].NoOfLosses;
                champs[champId].NoOfLvl30 += proc.Champs[champId].NoOfLvl30;
                champs[champId].NoOfMinions += proc.Champs[champId].NoOfMinions;
                champs[champId].NoOfPlayedGames += proc.Champs[champId].NoOfPlayedGames;
                champs[champId].NoOfSoloKills += proc.Champs[champId].NoOfSoloKills;
                champs[champId].NoOfWins += proc.Champs[champId].NoOfWins;
                //pentakill
                foreach (List<long> pentakillItems in proc.Champs[champId].PentakillItems)
                {
                    champs[champId].PentakillItems.Add(pentakillItems);
                }
            }
        }
    }

    public void AddGameAndCalculate(MatchDetail match)
    {
/*        try
        {*/
        noOfMatches++;
        Dictionary<int, MultikillCalculatorWithItems> participantsWithPentas = new Dictionary<int, MultikillCalculatorWithItems>();
        Dictionary<int, int> championDominanceFactor = new Dictionary<int, int>();

        //participantId, championId
        ObservableDictionary<int, int> participants = new ObservableDictionary<int, int>();
        foreach (Participant participant in match.Participants)
        {
            participants.Add(participant.ParticipantId, participant.ChampionId);
            champs[participant.ChampionId].NoOfPlayedGames++;
            if (participant.Stats.Winner)
            {
                champs[participant.ChampionId].NoOfWins++;



                int dominanceFactor = (int)(participant.Stats.Kills * 2 + participant.Stats.Assists - participant.Stats.Deaths * 3);
                championDominanceFactor.Add(participant.ChampionId, dominanceFactor);
            }
            else
            {
                champs[participant.ChampionId].NoOfLosses++;
            }

            //LVL 30
            if (participant.Stats.ChampLevel == 30)
                champs[participant.ChampionId].NoOfLvl30++;

            //DAMAGE DEALT
            champs[participant.ChampionId].DamageDealt += participant.Stats.TotalDamageDealtToChampions;

            //DAMAGE TAKEN
            champs[participant.ChampionId].DamageTaken += participant.Stats.TotalDamageTaken;

            //GOLD EARNED
            champs[participant.ChampionId].GoldEarned += participant.Stats.GoldEarned;

            //MINIONS
            champs[participant.ChampionId].NoOfMinions += participant.Stats.MinionsKilled;


            //CHECK IF CHAMPION HAS PENTAKILL
            if (participant.Stats.PentaKills != 0)
            {
                participantsWithPentas.Add(participant.ParticipantId, new MultikillCalculatorWithItems());
            }
        }
            
        //MVP
        int mvpChampionId = 0;
        int maxDF = 0;
        foreach (KeyValuePair<int, int> kvp in championDominanceFactor)
        {
            if (kvp.Value > maxDF)
                mvpChampionId = kvp.Key;
        }
        champs[mvpChampionId].MvpCount++;

        //Bans
        foreach(Team team in match.Teams)
        {
            if (team.Bans != null)
            {
                foreach (BannedChampion ban in team.Bans)
                {
                    champs[ban.ChampionId].BannedCount++;
                }
            }
        }


        foreach (Frame frame in match.Timeline.Frames)
        {
            if (frame.Events != null)
            {
                foreach (Event e in frame.Events)
                {
                    if (e.EventType.Equals(EventType.ChampionKill))
                    {
                        if (e.KillerId != 0)
                        {
                            ChampionStats champKiller = champs[participants[e.KillerId]];
                            ChampionStats champVictim = champs[participants[e.VictimId]];

                            champKiller.NoOfKills++;
                            champVictim.NoOfDeaths++;
                            if (e.AssistingParticipantIds != null)
                            {
                                foreach (int participantID in e.AssistingParticipantIds)
                                {
                                    champs[participants[participantID]].NoOfAssists++;
                                }
                            }
                            else
                                champKiller.NoOfSoloKills++;

                            //add kill if champ has pentakill
                            if (participantsWithPentas.ContainsKey(e.KillerId))
                            {
                                Dictionary<long, int> penta = participantsWithPentas[e.KillerId].AddKill(e.Timestamp.TotalMilliseconds);
                                if (penta != null)
                                {
                                    List<long> items = new List<long>();
                                    foreach (KeyValuePair<long, int> kvp in penta)
                                    {
                                        for (int i = 0; i < kvp.Value; i++)
                                        {
                                            items.Add(kvp.Key);
                                        }
                                    }
                                    champKiller.PentakillItems.Add(items);
                                }
                            }
                        }
                    }

                    if (participantsWithPentas.ContainsKey(e.ParticipantId) &&
                        (e.EventType.Equals(EventType.ItemPurchased) || e.EventType.Equals(EventType.ItemSold) 
                        || e.EventType.Equals(EventType.ItemDestroyed) || e.EventType.Equals(EventType.ItemUndo)))
                    {
                        if (e.EventType.Equals(EventType.ItemPurchased))
                            participantsWithPentas[e.ParticipantId].ItemPurchased(e);
                        else if (e.EventType.Equals(EventType.ItemUndo))
                        {
                            participantsWithPentas[e.ParticipantId].ItemUndo(e);
                        }
                        else
                            participantsWithPentas[e.ParticipantId].ItemDestroyedOrSold(e);
                    }
                }
            }
        }

     /*   }
        catch (Exception exc)
        {
            MessageBox.Show("Error! AddGameAndCalculate()");
        }*/
    }
    /*
    private void CalculateHeatmapDiedByChampions(ChampionInfo champKiller, ChampionInfo champVictim, Event e)
    {
        if (!champVictim.CollectionHeatmapDiedByChampions.ContainsKey(champKiller.Id))
        {
            HeatMap heatmap = new HeatMap();
            heatmap.Count++;
            heatmap.AddNewPoint(e.Position.X, e.Position.Y);
            champVictim.CollectionHeatmapDiedByChampions.Add(champKiller.Id, heatmap);
        }
        else
        {
            champVictim.CollectionHeatmapDiedByChampions[champKiller.Id].Count++;
            champVictim.CollectionHeatmapDiedByChampions[champKiller.Id].AddNewPoint(e.Position.X, e.Position.Y);
        }
    }

    private void CalculateHeatmapKilledChampions(ChampionInfo champKiller, ChampionInfo champVictim, Event e)
    {
        if (!champKiller.CollectionHeatmapKilledChampions.ContainsKey(champVictim.Id))
        {
            HeatMap heatmap = new HeatMap();
            heatmap.Count++;
            heatmap.AddNewPoint(e.Position.X, e.Position.Y);
            champKiller.CollectionHeatmapKilledChampions.Add(champVictim.Id, heatmap);
        }
        else
        {
            champKiller.CollectionHeatmapKilledChampions[champVictim.Id].Count++;
            champKiller.CollectionHeatmapKilledChampions[champVictim.Id].AddNewPoint(e.Position.X, e.Position.Y);
        }
    }

    private void CalculateBestAllyAndNoOfAssists(ChampionInfo champKiller, Event e, ObservableDictionary<int, int> participants)
    {
        foreach (int participant in e.AssistingParticipantIds)
        {
            int participantChampId = participants[participant];
            if (!champKiller.AllyDict.ContainsKey(participantChampId))
            {
                champKiller.AllyDict.Add(participantChampId, 1);
            }
            else
            {
                champKiller.AllyDict[participantChampId]++;
            }

            //increment assists
            champions[participantChampId].NoOfAssists++;
        }
    }
    */

    public void UpdateChampionsList()
    {
        StaticRiotApi staticApi = StaticRiotApi.GetInstance(apiKey);
        ChampionListStatic champs = staticApi.GetChampions(Region.eune);

        foreach (KeyValuePair<string, ChampionStatic> kvp in champs.Champions)
        {
            if (!Champs.ContainsKey(kvp.Value.Id))
            {
                ChampionStats champInfo = new ChampionStats(kvp.Value.Id, kvp.Value.Name, kvp.Value.Title);
                Champs.Add(kvp.Value.Id, champInfo);
            }
        }
    }

    #region sortedLists

    public List<ChampionStats> GetSortedListByNoOfPentaKills()
    {
        List<ChampionStats> sortedChamps = new List<ChampionStats>(Champs.Values);
        sortedChamps.Sort((firstPair, nextPair) =>
        {
            return -1 * firstPair.PentakillItems.Count.CompareTo(nextPair.PentakillItems.Count);
        }
        );
        return sortedChamps;
    }


    public List<ChampionStats> GetSortedListByNoOfPlayedMatch()
    {
        List<ChampionStats> sortedChamps = new List<ChampionStats>(Champs.Values);
        sortedChamps.Sort((firstPair, nextPair) =>
        {
            return -1 * firstPair.NoOfPlayedGames.CompareTo(nextPair.NoOfPlayedGames);
        }
        );
        return sortedChamps;
    }

    public List<ChampionStats> GetSortedListByBans()
    {
        List<ChampionStats> sortedChamps = new List<ChampionStats>(Champs.Values);
        sortedChamps.Sort((firstPair, nextPair) =>
        {
            double first = 0;
            double second = 0;
            if (firstPair.NoOfPlayedGames != 0)
                first = (double)firstPair.BannedCount / noOfMatches;
            if (nextPair.NoOfPlayedGames != 0)
                second = (double)nextPair.BannedCount / noOfMatches;

            if (first > second)
                return -1;
            else if (first < second)
                return 1;
            else
                return 0;
        }
        );
        return sortedChamps;
    }

    public List<ChampionStats> GetSortedListByLVL30()
    {
        List<ChampionStats> sortedChamps = new List<ChampionStats>(Champs.Values);
        sortedChamps.Sort((firstPair, nextPair) =>
        {
            double first = 0;
            double second = 0;
            if (firstPair.NoOfPlayedGames != 0)
                first = (double)firstPair.NoOfLvl30 / noOfMatches;
            if (nextPair.NoOfPlayedGames != 0)
                second = (double)nextPair.NoOfLvl30 / noOfMatches;

            if (first > second)
                return -1;
            else if (first < second)
                return 1;
            else
                return 0;
        }
        );
        return sortedChamps;
    }

    public List<ChampionStats> GetSortedListByNoOfMVP()
    {
        List<ChampionStats> sortedChamps = new List<ChampionStats>(Champs.Values);
        sortedChamps.Sort((firstPair, nextPair) =>
        {
            double first = 0;
            double second = 0;
            if (firstPair.NoOfPlayedGames != 0)
                first = (double)firstPair.MvpCount / firstPair.NoOfPlayedGames;
            if (nextPair.NoOfPlayedGames != 0)
                second = (double)nextPair.MvpCount / nextPair.NoOfPlayedGames;

            if (first > second)
                return -1;
            else if (first < second)
                return 1;
            else
                return 0;
        }
        );
        return sortedChamps;
    }

    public List<ChampionStats> GetSortedListByNoOfKills()
    {
        List<ChampionStats> sortedChamps = new List<ChampionStats>(Champs.Values);
        sortedChamps.Sort((firstPair, nextPair) =>
        {
            double first = 0;
            double second = 0;
            if (firstPair.NoOfPlayedGames != 0)
                first = (double)firstPair.NoOfKills / firstPair.NoOfPlayedGames;
            if (nextPair.NoOfPlayedGames != 0)
                second = (double)nextPair.NoOfKills / nextPair.NoOfPlayedGames;

            if (first > second)
                return -1;
            else if (first < second)
                return 1;
            else
                return 0;
        }
        );
        return sortedChamps;
    }

    public List<ChampionStats> GetSortedListByNoOfDeaths()
    {
        List<ChampionStats> sortedChamps = new List<ChampionStats>(Champs.Values);
        sortedChamps.Sort((firstPair, nextPair) =>
        {
            double first = 0;
            double second = 0;
            if (firstPair.NoOfPlayedGames != 0)
                first = (double)firstPair.NoOfDeaths / firstPair.NoOfPlayedGames;
            if (nextPair.NoOfPlayedGames != 0)
                second = (double)nextPair.NoOfDeaths / nextPair.NoOfPlayedGames;

            if (first > second)
                return 1;
            else if (first < second)
                return -1;
            else
                return 0;
        }
        );
        return sortedChamps;
    }

    public List<ChampionStats> GetSortedListByNoOfAssists()
    {
        List<ChampionStats> sortedChamps = new List<ChampionStats>(Champs.Values);
        sortedChamps.Sort((firstPair, nextPair) =>
        {
            double first = 0;
            double second = 0;
            if (firstPair.NoOfPlayedGames != 0)
                first = (double)firstPair.NoOfAssists / firstPair.NoOfPlayedGames;
            if (nextPair.NoOfPlayedGames != 0)
                second = (double)nextPair.NoOfAssists / nextPair.NoOfPlayedGames;

            if (first > second)
                return -1;
            else if (first < second)
                return 1;
            else
                return 0;
        }
        );
        return sortedChamps;
    }

    public List<ChampionStats> GetSortedListByNoOfSoloKills()
    {
        List<ChampionStats> sortedChamps = new List<ChampionStats>(Champs.Values);
        sortedChamps.Sort((firstPair, nextPair) =>
        {
            double first = 0;
            double second = 0;
            if (firstPair.NoOfPlayedGames != 0)
                first = (double)firstPair.NoOfSoloKills / firstPair.NoOfPlayedGames;
            if (nextPair.NoOfPlayedGames != 0)
                second = (double)nextPair.NoOfSoloKills / nextPair.NoOfPlayedGames;

            if (first > second)
                return -1;
            else if (first < second)
                return 1;
            else
                return 0;
        }
        );
        return sortedChamps;
    }

    public List<ChampionStats> GetSortedListByNoOfMinions()
    {
        List<ChampionStats> sortedChamps = new List<ChampionStats>(Champs.Values);
        sortedChamps.Sort((firstPair, nextPair) =>
        {
            double first = 0;
            double second = 0;
            if (firstPair.NoOfPlayedGames != 0)
                first = (double)firstPair.NoOfMinions / firstPair.NoOfPlayedGames;
            if (nextPair.NoOfPlayedGames != 0)
                second = (double)nextPair.NoOfMinions / nextPair.NoOfPlayedGames;

            if (first > second)
                return -1;
            else if (first < second)
                return 1;
            else
                return 0;
        }
        );
        return sortedChamps;
    }

    public List<ChampionStats> GetSortedListByDmgDealt()
    {
        List<ChampionStats> sortedChamps = new List<ChampionStats>(Champs.Values);
        sortedChamps.Sort((firstPair, nextPair) =>
        {
            double first = 0;
            double second = 0;
            if (firstPair.NoOfPlayedGames != 0)
                first = (double)firstPair.DamageDealt / firstPair.NoOfPlayedGames;
            if (nextPair.NoOfPlayedGames != 0)
                second = (double)nextPair.DamageDealt / nextPair.NoOfPlayedGames;

            if (first > second)
                return -1;
            else if (first < second)
                return 1;
            else
                return 0;
        }
        );
        return sortedChamps;
    }

    public List<ChampionStats> GetSortedListByNoOfWins()
    {
        List<ChampionStats> sortedChamps = new List<ChampionStats>(Champs.Values);
        sortedChamps.Sort((firstPair, nextPair) =>
        {
            double first = 0;
            double second = 0;
            if (firstPair.NoOfPlayedGames != 0)
                first = (double)firstPair.NoOfWins / firstPair.NoOfPlayedGames;
            if (nextPair.NoOfPlayedGames != 0)
                second = (double)nextPair.NoOfWins / nextPair.NoOfPlayedGames;

            if (first > second)
                return -1;
            else if (first < second)
                return 1;
            else
                return 0;
        }
        );
        return sortedChamps;
    }

    public List<ChampionStats> GetSortedListByDamageTaken()
    {
        List<ChampionStats> sortedChamps = new List<ChampionStats>(Champs.Values);
        sortedChamps.Sort((firstPair, nextPair) =>
        {
            double first = 0;
            double second = 0;
            if (firstPair.NoOfPlayedGames != 0)
                first = (double)firstPair.DamageTaken / firstPair.NoOfPlayedGames;
            if (nextPair.NoOfPlayedGames != 0)
                second = (double)nextPair.DamageTaken / nextPair.NoOfPlayedGames;

            if (first > second)
                return -1;
            else if (first < second)
                return 1;
            else
                return 0;
        }
        );
        return sortedChamps;
    }

    public List<ChampionStats> GetSortedListByGoldEarned()
    {
        List<ChampionStats> sortedChamps = new List<ChampionStats>(Champs.Values);
        sortedChamps.Sort((firstPair, nextPair) =>
        {
            double first = 0;
            double second = 0;
            if (firstPair.NoOfPlayedGames != 0)
                first = (double)firstPair.GoldEarned / firstPair.NoOfPlayedGames;
            if (nextPair.NoOfPlayedGames != 0)
                second = (double)nextPair.GoldEarned / nextPair.NoOfPlayedGames;

            if (first > second)
                return -1;
            else if (first < second)
                return 1;
            else
                return 0;
        }
        );
        return sortedChamps;
    }

    #endregion

    #region Serialization
    public void GetObjectData(SerializationInfo info, StreamingContext ctxt)
    {
        info.AddValue("champs", this.champs);
        info.AddValue("noOfMatches", this.noOfMatches);
    }

    protected ChampionsProcessor(SerializationInfo info, StreamingContext context)
    {
        if (info == null)
            throw new System.ArgumentNullException("info");
        champs = (ObservableDictionary<int, ChampionStats>)info.GetValue("champs", typeof(ObservableDictionary<int, ChampionStats>));
        noOfMatches = (int)info.GetValue("noOfMatches", typeof(int));
    }
    #endregion












}//end ChampionsProcessor